
# \d 可以匹配一个数字
# \w 可以匹配一个字母或数字
# . 可以匹配任意字符
# * 表示任意个字符（包括0个）
# + 表示至少一个字符
# ? 表示0个或1个字符
# {n} 表示n个字符
# {n,m} 表示n-m个字符

# eg: \d{3}\s+\d(3,8)
# ************* 解读 ***************
# \d(3) 表示匹配3个数字，例如 ‘010’
# \s 可以匹配一个空格（也包括tab等空白符），所以
# \s+ 表示至少有一个空格
# \d(3-8) 表示3-8个数字，例如 ‘1234567’

# [0-9a-zA-Z\_] 可以匹配一个数字、字母或者下划线
# [0-9a-zA-Z\_]+ 可以匹配至少由一个数字、字母或者下划线组成的字符串
# [a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开头，后接任意个由数字、字母或者下划线组成的字符串，也就是python合法的变量
# [a-zA-Z\_][0-9a-zA-Z\_]{0,19} 更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）
# A|B 可以匹配A或者B
# ^ 表示行的开头， ^\d 表示必须以数字开头
# $ 表示行的结束， \d$ 表示必须以数字结束

# Python的字符串本身也用\转义，所以要特别注意
s1 = 'ABC\\-001'
print(s1)
# 强烈建议使用Python的r前缀，就不用考虑转义的问题了
s2 = r'ABC\-001'
print(s2)

import re

if re.match(r'^\d{3}\-\d{3,8}$', '010-12345'):
    print('ok')
else:
    print('failed')

# 常规的切分字符串
l1 = 'a b   c'.split(' ')
print(l1)
# 正则表达式切分
l2 = re.split(r'\s+', 'a b   c')
print(l2)

# 解决正则匹配的贪婪匹配
m1 = re.match(r'^(\d+)(0*)$', '102300').groups()
print(m1)
# ('102300', '')
# 让\d+采用非贪婪匹配（也就是尽可能少匹配），
# 才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配
m2 = re.match(r'^(\d+?)(0*)$', '102300').groups()
print(m2)
# ('1023', '00')

# 正则表达式的预编译
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用
m3 = re_telephone.match('010-12345')
print(m3.group(1), m3.group(2), m3.group(0))
print(m3.groups())


